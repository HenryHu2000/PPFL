// Copyright (c) Open Enclave SDK contributors.
// Licensed under the MIT License.

#include <stdio.h>
#include <stdlib.h>

// Include the trusted secure aggregation header that is generated
// during the build. This file is generated by calling the
// sdk tool oeedger8r against the secure_aggregation.edl file.
#include "secure_aggregation_t.h"
#include "aes.h"

int debug=1;
float* aggregate_buf;
int countp;

void aes_cbc_TA(char* xcrypt, float* gradient, int org_len)
{
    //convert float array to uint_8 one by one
    uint8_t *byte;
    uint8_t array[org_len*4];
    for(int z = 0; z < org_len; z++){
        byte = (uint8_t*)(&gradient[z]);
        for(int y = 0; y < 4; y++){
            array[z*4 + y] = byte[y];
        }
    }

    //set ctx, iv, and key for aes
    int enc_len = (int)(org_len/4);
    struct AES_ctx ctx;
    uint8_t iv[] = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f };
    uint8_t key[16] = { (uint8_t)0x2b, (uint8_t)0x7e, (uint8_t)0x15, (uint8_t)0x16, (uint8_t)0x28, (uint8_t)0xae, (uint8_t)0xd2, (uint8_t)0xa6, (uint8_t)0xab, (uint8_t)0xf7, (uint8_t)0x15, (uint8_t)0x88, (uint8_t)0x09, (uint8_t)0xcf, (uint8_t)0x4f, (uint8_t)0x3c };

    //encryption
    AES_init_ctx_iv(&ctx, key, iv);
    for (int i = 0; i < enc_len; ++i)
    {
        if(strncmp(xcrypt, "encrypt", 2) == 0){
            AES_CBC_encrypt_buffer(&ctx, array + (i * 16), 16);
        }else if(strncmp(xcrypt, "decrypt", 2) == 0){
            AES_CBC_decrypt_buffer(&ctx, array + (i * 16), 16);
        }
    }

    //convert uint8_t to float one by one
    for(int z = 0; z < org_len; z++){
        gradient[z] = *(float*)(&array[z*4]);
    }
}

void copy_cpu_TA(int N, float *X, int INCX, float *Y, int INCY)
{
    int i;
    for(i = 0; i < N; ++i) {
        Y[i*INCY] = X[i*INCX];
    }
}


// This is the function that the host calls. It prints
// a message in the enclave before calling back out to
// the host to print a message from there too.
void enclave_initialize(
    float* input_buf,
    size_t buf_size)
{
    // fprintf(stdout, "Secure aggregation from the enclave\n");
    //
    // // Call back into the host
    // oe_result_t result = host_secure_aggregation();
    // if (result != OE_OK)
    // {
    //     fprintf(
    //         stderr,
    //         "Call to host_secure_aggregation failed: result=%u (%s)\n",
    //         result,
    //         oe_result_str(result));
    // }

    // malloc memory for aggregate_buf

    aes_cbc_TA("decrypt", input_buf, (int)buf_size);

    if (debug==1){
        printf("\ntee--- net 0: ");
        for(size_t z=0; z<5; z++)
        {
            printf("%f, ", input_buf[z]);
        }
    }

    aggregate_buf = malloc(sizeof(float) * buf_size);
    countp = 1;
    for(size_t i=0; i<buf_size; i++)
    {
        aggregate_buf[i] = input_buf[i];
    }
}



void enclave_secure_aggregation(
    bool last_one,
    float* input_buf,
    float* output_buf,
    size_t buf_size)
{
   // add input_buf to aggregated buf

   aes_cbc_TA("decrypt", input_buf, (int)buf_size);

   if (debug==1){
       printf("\ntee--- net 1: ");
       for(size_t z=0; z<5; z++)
       {
           printf("%f, ", input_buf[z]);
       }
   }

   for(size_t i=0; i<buf_size; i++)
   {
       aggregate_buf[i] += input_buf[i];
   }

   countp++;

   // the last one then averaging

   if(last_one)
   {
       for(size_t i=0; i<buf_size; i++){
           output_buf[i] = aggregate_buf[i] / countp;
       }

       if (debug==1){
           printf("\ntee--- net a: ");
           for(size_t z=0; z<5; z++)
           {
               printf("%f, ", output_buf[z]);
           }
       }

       free(aggregate_buf);
   }

   aes_cbc_TA("encrypt", output_buf, (int)buf_size);

}



void enclave_weights_decryption(
    float* input_buf,
    size_t buf_size)
{
    if (debug==1){
        printf("\ndecryption before: ");
        for(size_t z=0; z<5; z++)
        {
            printf("%f, ", input_buf[z]);
        }
    }

    aes_cbc_TA("decrypt", input_buf, (int)buf_size);

    if (debug==1){
        printf("\ndecryption after: ");
        for(size_t z=0; z<5; z++)
        {
            printf("%f, ", input_buf[z]);
        }
    }
}


void enclave_weights_encryption(
    float* input_buf,
    size_t buf_size)
{
    if (debug==1){
        printf("\nencryption before: ");
        for(size_t z=0; z<5; z++)
        {
            printf("%f, ", input_buf[z]);
        }
    }

    aes_cbc_TA("encrypt", input_buf, (int)buf_size);

    if (debug==1){
        printf("\nencryption after: ");
        for(size_t z=0; z<5; z++)
        {
            printf("%f, ", input_buf[z]);
        }
    }
}
